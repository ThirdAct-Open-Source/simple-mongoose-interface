import {Model, ObjectId, Document, ToObjectOptions, FilterQuery} from 'mongoose';
import { apply_patch } from 'jsonpatch';
import * as _ from 'lodash';

import {
  ToPojo,
  ToPojoOptions
} from '@thirdact/to-pojo';

/**
 * The fields of a Mongoose query.
 *
 * See the [Mongoose documentation](https://mongoosejs.com/docs/api.html#model_Model.find) for more info.
 */
export interface QueryFieldSelection {
  [field: string]: number;
}

/**
 * Either the fields in a projection as an object or a string.
 *
 * See the [Mongoose documentation](https://mongoosejs.com/docs/api.html#model_Model.find) for more info.
 */
export type QueryProjection = QueryFieldSelection|string[]|string;

/**
 * Either the fields in a sort as an object or a string.
 *
 * See the [Mongoose documentation](https://mongoosejs.com/docs/api.html#query_Query-sort) for more info.
 */
export type QuerySort = QueryFieldSelection|string;

export type IDType = string|ObjectId|Buffer;

/**
 * The base for a query represented as an object.
 */
export interface QueryBase {
  /**
   * The sort document or string
   */
  sort?: QuerySort;
  /**
   * The projection document or string
   */
  project?: QueryProjection;
  /**
   * Fields to populate
   */
  populate?: string;
  /**
   * Limit the query results by this value
   */
  limit?: number;
  /**
   * Skip query results by this value
   */
  skip?: number;
}

/**
 * A standard query, in addition to arbitrary fields to query on
 */
export type Query<T> = QueryBase&{
  /**
   * Arbitrary fields to query on
   */
  query: FilterQuery<T>
};

/**
 * Query base but keyword, for text search, instead of arbitrary fields
 */
export  type TextQuery = QueryBase&{
  keyword: string;
};

/**
 * Operations for a JSON Patch request.
 *
 * See the [JSON Patch documentation](http://jsonpatch.com/#operations) for more info.
 */
export enum JSONPatchOp {
  /**
   * See the [JSON Patch documentation](http://jsonpatch.com/#add) for more info.
  */
  add = 'add',
  /**
   * See the [JSON Patch documentation](http://jsonpatch.com/#remove) for more info.
   */
  remove = 'remove',
  /**
   * See the [JSON Patch documentation](http://jsonpatch.com/#replace) for more info.
   */
  replace = 'replace',
  /**
   * See the [JSON Patch documentation](http://jsonpatch.com/#copy) for more info.
   */
  copy = 'copy',
  /**
   * See the [JSON Patch documentation](http://jsonpatch.com/#move) for more info.
   */
  move = 'move',
  /**
   * See the [JSON Patch documentation](http://jsonpatch.com/#test) for more info.
   */
  test = 'test'
}

/**
 * Base of JSON Patch request.
 *
 * See the [JSON Patch documentation](http://jsonpatch.com) for more info.
 */
export interface JSONPatchBase {
  op: JSONPatchOp;
  path: string;
}

/**
 * A JSON Patch request.
 *
 * See the [JSON Patch documentation](http://jsonpatch.com) for more info.
 */
export type JSONPatch = JSONPatchBase&(
  { op: JSONPatchOp.add|JSONPatchOp.replace|JSONPatchOp.test, value: any } |
  { op: JSONPatchOp.copy|JSONPatchOp.move, from: string } |
  { op: JSONPatchOp.remove }
)

export interface ModelInterfaceRequestBodyOptions {
  upsert?: boolean;
}

/**
 * The body of a request intended as a Mongoose `find` operation.
 */
export type QueryModelInterfaceRequestBody<T> = {
  options?: ModelInterfaceRequestBodyOptions;
  query: Query<T>;
}

/**
 * The body of a request intended as a Mongoose `findById` operation.
 */
export type FindByIdModelInterfaceRequestBody<T> = {
  options?: ModelInterfaceRequestBodyOptions;
  id: IDType;
}

/**
 * The body of a request intended as a Mongoose `create` operation.
 */
export type CreateModelInterfaceRequestBody<T> = {
  options?: ModelInterfaceRequestBodyOptions;
  fields: T;
}

/**
 * The body of a request intended as a Mongoose `update` operation,
 * but will apply a series of [JSON Patch](http://jsonpatch.com) objects to
 * located document.
 */
export type PatchModelInterfaceRequestBody<T> = QueryModelInterfaceRequestBody<T>&{
  options?: ModelInterfaceRequestBodyOptions;
  patches: JSONPatch[];
}

/**
 * The body of a request intended as a Mongoose `update` operation,
 * by simply overwriting the values on the located document with the values enclosed in the body.
 */
export type UpdateModelInterfaceRequestBody<T> = QueryModelInterfaceRequestBody<T>&CreateModelInterfaceRequestBody<T>;

/**
 * The body of a model interface request
 */
export type ModelInterfaceRequestBody<T> = FindByIdModelInterfaceRequestBody<T>|PatchModelInterfaceRequestBody<T>|QueryModelInterfaceRequestBody<T>|CreateModelInterfaceRequestBody<T>|UpdateModelInterfaceRequestBody<T>;

export const IsModelInterfaceError = Symbol('ModelInterfaceError');

/**
 * Represents error generated by the execution of a `ModelInterface` request.
 */
export interface ModelInterfaceError {
  /**
   * Error message as a string
   */
  message: string;
  /**
   * HTTP code that will be sent if the response is over HTTP
   */
  httpCode?: number;
  /**
   * An inner error, if this error was generated by wrapping an existing error.
   */
  innerError?: Error|ModelInterfaceError;
  /**
   * Stacktrace of the inner error if available
   */
  stack?: string;
  /**
   * Indicates if the object is in fact a ModelInterfaceError
   */
  isModelInterfaceError: typeof IsModelInterfaceError
}


/**
 * The various methods available for each requests
 */
export enum ModelInterfaceRequestMethods {
  /**
   * Analogous to Mongoose's `find`
   */
  find = 'find',
  /**
   * Analogous to Mongoose's `findOne`
   */
  findOne = 'findOne',
  /**
   * Analogous to Mongoose's `updateMany`
   */
  update = 'update',
  /**
   * Analogous to Mongoose's `findById`
   */
  findById = 'findById',
  /**
   * Analogous to Mongoose's `find` + `count`
   */
  count = 'count',
  /**
   * Analogous to Mongoose's `create`
   */
  create = 'create',
  /**
   * First uses a `find` then `apply_patch` from `jsonpatch` to each document, then saves
   */
  patch = 'patch',
  /**
   * Analogous to Mongoose's `deleteMany`
   */
  delete = 'delete'
}

/**
 * The full `ModelInterfaceRequest`
 */
export type ModelInterfaceRequest<T> = { id?: string;}&({
  method: ModelInterfaceRequestMethods.find|ModelInterfaceRequestMethods.findOne|ModelInterfaceRequestMethods.delete|ModelInterfaceRequestMethods.count;
  body: QueryModelInterfaceRequestBody<T>;
}|{
  method: ModelInterfaceRequestMethods.update;
  body: UpdateModelInterfaceRequestBody<T>
}|{
  method: ModelInterfaceRequestMethods.create;
  body: CreateModelInterfaceRequestBody<T>
}|{
  method: ModelInterfaceRequestMethods.patch;
  body: PatchModelInterfaceRequestBody<T>
}|{
  method: ModelInterfaceRequestMethods.findById;
  body: FindByIdModelInterfaceRequestBody<T>
}|{
  method: ModelInterfaceRequestMethods;
  body: ModelInterfaceRequestBody<T>;
});

export type ModelInterfaceResponseResults<T> = T[]|Document<T>[];
export type ModelInterfaceResponseResult<T> = T|Document<T>;
export type ModelInterfaceResponseCount = {
  count: number;
};
export type ModelInterfaceResponseCreate = {
  id: IDType;
}

export type ModelInterfaceUpdateResponse = {
  updated: number,
  upserted: IDType[]
}

export type ModelInterfaceResponse<T> = { id?: string; body: {  error?: ModelInterfaceError;  } }&({
  method: ModelInterfaceRequestMethods.find
  body: {
    results: ModelInterfaceResponseResults<T>;
  }
}|{
  method: ModelInterfaceRequestMethods.findOne|ModelInterfaceRequestMethods.findById;
  body: {
    result: ModelInterfaceResponseResult<T>|null;
  }
}|{
  method: ModelInterfaceRequestMethods.delete,
  body: null
}|{
  method: ModelInterfaceRequestMethods.update|ModelInterfaceRequestMethods.patch
  body: ModelInterfaceUpdateResponse
}|{
  method: ModelInterfaceRequestMethods.create;
  body: ModelInterfaceResponseCreate
}|{
  method: ModelInterfaceRequestMethods.count;
  body: ModelInterfaceResponseCount;
}|{
  method: ModelInterfaceRequestMethods;
  body: unknown;
});


export class InvalidMethodError extends Error {
  constructor(method: string) {
    super(`Invalid method ${method}`)
  }
}

/**
 * Extra options for the `ModelInterface`
 */
export type ModelInterfaceOptions = {
  /**
   * Default options for when `toPojo` is run agaist Mongoose `Document`s
   */
  toPojoOptions?: ToPojoOptions<any, any>
}

/**
 * Default `ModelInterfaceOptions`
 */
export const DEFAULT_MODEL_INTERFACE_OPTIONS: ModelInterfaceOptions = Object.freeze({});
/**
 * Default `ModelInterfaceOptions` for `SimpleModelInterface`
 * Converts `ObjectId`s to `String`s by default, and converts `Map`s to plain `Object`s
 */
export const DEFAULT_SIMPLE_MODEL_INTERFACE_OPTIONS: ModelInterfaceOptions = Object.freeze({

})

/**
 * An interface on-top of a Mongoose model that can be used for CRUD operations
 */
export class ModelInterface<T> {
  constructor(protected model: Model<T>, public options: ModelInterfaceOptions = {...DEFAULT_MODEL_INTERFACE_OPTIONS})  {

  }

  /**
   * Returns the name of the underlying Mongoose model
   */
  get name(): string { return this.model.modelName; }

  /**
   * Returns a `ModelInterfaceError` from an `Error` or existing `ModelInterfaceError`,
   * if an `Error` is passed, a `ModelInterfaceError` is returned  with the error passed
   * as `innerError`.
   * @param err Error to wrap
   */
  public wrapError(err: Error|ModelInterfaceError) {
    if ((err as ModelInterfaceError).isModelInterfaceError === IsModelInterfaceError) {
      return err as ModelInterfaceError;
    } else {
      return {
        message: err.message,
        httpCode: (err as any).httpCode || 500,
        innerError: err,
        stack: err.stack,
        isModelInterfaceError: IsModelInterfaceError
      }
    }
  }

  /**
   * Executes a Mongoose Interface request, from the instructions
   * provided in the object passed.
   *
   * @param request Mongoose request to execute
   */
  public async execute(request: ModelInterfaceRequest<T>): Promise<ModelInterfaceResponse<T>> {
    const result: unknown = await (async () => {
      try {
        switch (request.method) {
          case ModelInterfaceRequestMethods.find:
          case ModelInterfaceRequestMethods.findOne:
          case ModelInterfaceRequestMethods.count:
          case ModelInterfaceRequestMethods.delete:
            return (this as any)[request.method](
              (request.body as QueryModelInterfaceRequestBody<T>).query
            );
          case ModelInterfaceRequestMethods.update:
            return (this as any)[request.method](
              (request.body as UpdateModelInterfaceRequestBody<T>).query,
              (request.body as UpdateModelInterfaceRequestBody<T>).fields
            );
          case ModelInterfaceRequestMethods.patch:
            return (this as any)[request.method](
              (request.body as UpdateModelInterfaceRequestBody<T>).query,
              (request.body as PatchModelInterfaceRequestBody<T>).patches
            );
          case ModelInterfaceRequestMethods.findById:
            return (this as any)[request.method](
              (request.body as FindByIdModelInterfaceRequestBody<T>).id || (request.body as any).query._id,
            );
          case ModelInterfaceRequestMethods.create:
            return (this as any)[request.method](
              (request.body as CreateModelInterfaceRequestBody<T>).fields
            );
          default:
            throw new InvalidMethodError((request as any).method as string);
        }
      } catch (err) {
        const wrappedError =  this.wrapError(err);
        return  {
          method: request.method,
          body: {
            error: wrappedError
          }
        } as ModelInterfaceResponse<T>
      }
    })() as ModelInterfaceResponse<T>;


    switch(request.method) {
      case ModelInterfaceRequestMethods.find:
        return { method: request.method, id: request.id, body: { results: result as Document<T>[] } };
      case ModelInterfaceRequestMethods.findOne:
      case ModelInterfaceRequestMethods.findById:
        return { method: request.method, id: request.id, body: { result: (result as Document<T>|T|null)||null as Document<T>|null } };
      case ModelInterfaceRequestMethods.count:
        return { method: request.method, id: request.id, body: { count: result as number } };
      case ModelInterfaceRequestMethods.create:
        return { method: request.method, id: request.id, body: { id: result as any } };
      case ModelInterfaceRequestMethods.patch:
      case ModelInterfaceRequestMethods.update:
      case ModelInterfaceRequestMethods.delete:
        return { method: request.method, id: request.id, body: null };
    }
  }

  /**
   * Attempts to return a plain old javascript object (POJO) of the input provided.
   * Will return  `null` if `null` or `undefined` or passed as input,
   * the input itself if the input isn't an object, then will attempt to call
   * `toJSON` and `toObject` on the object (in that order).
   *
   * If `toJSON` and `toObject` does not exist will return the result of `lodash`'s
   * `_.cloneDeep` on the input.
   *
   * If an `Array` is provided, will run itself recursively against all objects in the input array.
   * @param doc Document to convert
   * @param options
   */
  public static toPojo<T>(doc: Document<T>|Document<T>[]|null|undefined, options: ToPojoOptions<Document<T>|Document<T>[]|null|undefined, T> = DEFAULT_MODEL_INTERFACE_OPTIONS.toPojoOptions): T|T[]|null {
    const runner = new ToPojo<Document<T>|Document<T>[]|null|undefined,T>();
    return runner.toPojo(doc, options || runner.DEFAULT_TO_POJO_OPTIONS);
  }

  /**
   * Attempts to return a plain old javascript object (POJO) of the input provided.
   * Will return  `null` if `null` or `undefined` or passed as input,
   * the input itself if the input isn't an object, then will attempt to call
   * `toJSON` and `toObject` on the object (in that order).
   *
   * If `toJSON` and `toObject` does not exist will return the result of `lodash`'s
   * `_.cloneDeep` on the input.
   *
   * If an `Array` is provided, will run itself recursively against all objects in the input array.
   * @param doc Document to convert
   * @param options
   */
  public toPojo(doc: Document<T>|Document<T>[]|null|undefined, options: ToPojoOptions<Document<T>|Document<T>[]|null|undefined,T> = this.options.toPojoOptions): T|T[]|null {
    return ModelInterface.toPojo<T>(doc, options);
  }

  protected ensureQuery(query: Query<T>): Query<T> {
    query = _.cloneDeep(query || { query: {} });
    query.query = query.query || {};

    return query;
  }

  /**
   * Constructs a Mongoose query from the `Query` provided.
   * @param query Original query
   */
  public createQuery(query: Query<T>) {
    query = this.ensureQuery(query);
    const q = query?.query?._id ? this.model.findById(query.query._id, query.project) : this.model.find(query.query as any, query.project);

    if (query.sort) q.sort(query.sort);
    if (query.skip) q.skip(query.skip);
    if (query.limit) q.limit(query.limit);
    if (!_.isEmpty(query.populate))
      q.populate(query.populate);

    return q;
  }

  /**
   * Runs a Mongoose `find` based on the query  provided
   * @param query Query used in the `find` operation
   */
  public async find(query: Query<T>): Promise<Document<T>[]> {
    query = this.ensureQuery(query);
    const q = this.createQuery(query);
    return [].concat((await q.exec())) as Document<T>[];
  }

  /**
   * Runs a Mongoose `findOne` based on the query  provided
   * @param query Query used in the `findOne` operation
   */
  public async findOne(query: Query<T>): Promise<Document<T>|null> {
    query = this.ensureQuery(query);
    return (await this.find(query))[0] as Document<T>;
  }

  /**
   * Runs a Mongoose `findById` based on the query  provided
   * @param query Query used in the `findById` operation
   */
  public async findById(id: IDType): Promise<Document<T>|null> {
    return (await this.model.findById(id)) as Document<T> || null;
  }

  /**
   * Runs a Mongoose `find` then `count` based on the query  provided
   * @param query Query used in the `find` then `count` operation
   */
  public async count(query: Query<T>): Promise<number> {
    query = this.ensureQuery(query);
    const q = this.createQuery(query);
    return q.count().exec();
  }

  /**
   * Runs a Mongoose `create` based on the fields  provided
   * @param query Fields used in the `create` operation
   */
  public async create(fields: T): Promise<IDType> {
    const doc = await this.model.create(fields);
    return doc.id;
  }

  /**
   * Runs a Mongoose `update` based on the query and fields  provided
   * @param query Query used in the `update` operation
   * @param  fields Query used in the `update` operation
   */
  public async update(query: Query<T>, fields: T, upsert?: boolean): Promise<ModelInterfaceUpdateResponse> {
    query = this.ensureQuery(query);
    if (query?.query?._id) {
      const mod = await this.model.findById(query?.query?._id, { _id: 1 }).exec();
      if (mod) {
        for (let k in fields) {
          (mod as any)[k] = fields[k];
        }
        await mod.save();
        return { updated: 1, upserted: [] };
      } else {
        return { updated: 0, upserted: [] };
      }
    }
      const result = await this.model.updateMany(query.query as any, fields, {
        upsert
      }).exec();

    return {
      updated: result.nModified,
      upserted: (result.upserted || []).map(u => u._id)
    };
  }

  /**
   * Runs a function upon each object returned by the query
   * @param query Query to use
   * @param fn Function to call for each object
   * @protected
   */
  protected async forEach(query: Query<T>, fn: (doc: Document<T>) => Promise<void>): Promise<void> {
    query = this.ensureQuery(query);
    let doc: Document<T>;
    const cur = this.createQuery(query).cursor();
    while (doc = await cur.next() as Document<T>) {
      await fn(doc);
    }
  }

  /**
   * Runs a series of JSON patches on all objects matched by the query
   * @param query Query to match with
   * @param patches Patches to apply
   */
  public async patch(query: Query<T>, patches: JSONPatch[]): Promise<ModelInterfaceUpdateResponse> {
    query = this.ensureQuery(query);
    const upserted: IDType[] = [];
    let updated = 0;
    await this.forEach(query, async (doc) => {
      if (doc.isNew)
        upserted.push((doc as any)._id as IDType);
      const delta = apply_patch((doc as any).toObject({ virtuals: false }), patches);
      _.extend(doc, delta);
      await doc.save();
      updated++;
    });

    return { upserted, updated };
  }

  /**
   * Deletes all documents matching the query provided
   * @param query Query to match with
   */
  public async delete(query: Query<T>): Promise<void> {
    query = this.ensureQuery(query);
     await this.model.deleteMany(query.query as any);
  }
}

/**
 * A stripped down version of the `SimpleModelInterface` that returns POJOs instead of Mongoose documents
 */
export class SimpleModelInterface<T> {
  constructor(public modelInterface: ModelInterface<T>, public options: ModelInterfaceOptions = {...DEFAULT_SIMPLE_MODEL_INTERFACE_OPTIONS})  {
    (modelInterface).options = options;
  }

  /**
   * Runs a Mongoose `find` based on the query  provided
   * @param query Query used in the `find` operation
   */
  public async find(query: Query<T>): Promise<T[]> {
    return this.modelInterface.toPojo(await this.modelInterface.find(query)) as T[];
  }

  /**
   * Runs a Mongoose `findOne` based on the query  provided
   * @param query Query used in the `findOne` operation
   */
  public async findOne(query: Query<T>): Promise<T|null> {
    return this.modelInterface.toPojo(await this.modelInterface.findOne(query)) as T|null;
  }

  /**
   * The body of a request intended as a Mongoose `findById` operation.
   */
  public async findById(id: string): Promise<T|null> {
    return this.modelInterface.toPojo(await this.modelInterface.findById(id)) as T|null;
  }

  /**
   * Runs a Mongoose `find` then `count` based on the query  provided
   * @param query Query used in the `find` then `count` operation
   */
  public async count(query: Query<T>): Promise<number> {
    return this.modelInterface.count(query);
  }

  /**
   * Runs a Mongoose `create` based on the fields  provided
   * @param query Fields used in the `create` operation
   */
  public async create(fields: T): Promise<string> {
    return (await this.modelInterface.create(fields)).toString();
  }

  /**
   * Runs a Mongoose `update` based on the query and fields  provided
   * @param query Query used in the `update` operation
   * @param  fields Query used in the `update` operation
   */
  public async update(query: Query<T>, fields: T, upsert?: boolean): Promise<ModelInterfaceUpdateResponse> {
    return this.modelInterface.update(query, fields, upsert);
  }

  /**
   * Runs a series of JSON patches on all objects matched by the query
   * @param query Query to match with
   * @param patches Patches to apply
   */
  public async patch(query: Query<T>, patches: JSONPatch[]): Promise<ModelInterfaceUpdateResponse> {
    return this.modelInterface.patch(query, patches);
  }

  /**
   * Deletes all documents matching the query provided
   * @param query Query to match with
   */
  public async delete(query: Query<T>): Promise<void> {
    return this.modelInterface.delete(query);
  }

  /**
   * Executes a Mongoose Interface request, from the instructions
   * provided in the object passed.
   *
   * @param request Mongoose request to execute
   */
  public async execute(request: ModelInterfaceRequest<T>): Promise<ModelInterfaceResponse<T>> {
    const response = await this.modelInterface.execute(request);

    if (typeof(response.body) !== 'undefined' && response.body !== null) {
      // @ts-ignore
      response.body = this.modelInterface.toPojo(response.body);
    }

    return response;
  }
}

